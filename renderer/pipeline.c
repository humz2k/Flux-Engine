#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include "raylib.h"
#include "raymath.h"
#include "transform.h"
#include "pipeline.h"
#include "shader_manager.h"

#define Vec32Array(vec) { vec.x, vec.y, vec.z }

static Camera3D current_camera;

struct render_object{
    Model model;
    Vector3 pos;
    Vector3 scale;
    Color tint;
    Vector3 rotation_axis;
    float rotation_amount;
};

typedef struct renderModelInternal{
    Model model;
    int n_instances;
    Color tints[RENDER_MAX_INSTANCES];
    Matrix transforms[RENDER_MAX_INSTANCES];
} renderModelInternal;

static int n_objects = 0;
static int n_rmodels = 0;
static struct render_object objects[RENDERER_MAX_OBJECTS];
static renderModel rmodels[RENDERER_MAX_OBJECTS];
static Shader default_shader;
static int draw_grid = 0;
static int n_grid;
static float spacing_grid;

renderModel render_make_model(Model model){
    renderModel out = (renderModel)malloc(sizeof(renderModelInternal));
    out->n_instances = 0;
    out->model = model;
    return out;
}

static Matrix get_mesh_transform(Model model, fluxTransform transform){
    // Calculate transformation matrix from function parameters
    // Get transform matrix (rotation -> scale -> translation)
    Vector3 rotationAxis; float rotationAngle;
    Quaternion qrot = QuaternionFromEuler(Wrap(transform.rot.x,0,2*M_PI),Wrap(transform.rot.y,0,2*M_PI),Wrap(transform.rot.z,0,2*M_PI));
    QuaternionToAxisAngle(qrot,&rotationAxis,&rotationAngle);
    Matrix matScale = MatrixScale(transform.scale.x, transform.scale.y, transform.scale.z);
    Matrix matRotation = MatrixRotate(rotationAxis, rotationAngle*DEG2RAD);
    Matrix matTranslation = MatrixTranslate(transform.pos.x, transform.pos.y, transform.pos.z);

    Matrix matTransform = MatrixMultiply(MatrixMultiply(matScale, matRotation), matTranslation);

    // Combine model transformation matrix (model.transform) with matrix generated by function parameters (matTransform)
    return MatrixMultiply(model.transform, matTransform);
}

void render_reset_instances(renderModel model){
    assert(model);
    model->n_instances = 0;
}


void render_add_model_instance(renderModel model, fluxTransform transform, Color tint){
    assert(model);
    assert(model->n_instances < RENDER_MAX_INSTANCES);
    model->tints[model->n_instances] = tint;
    model->transforms[model->n_instances] = get_mesh_transform(model->model,transform);
    model->n_instances++;
}

void render_rmodel(renderModel rmodel){
    assert(rmodel);
    assert(n_rmodels < RENDERER_MAX_OBJECTS);
    rmodels[n_rmodels] = rmodel;
    n_rmodels++;
}

void render_free_model(renderModel model){
    assert(model);
    free(model);
}

void render_init(void){
    render_load_default_shader();
    default_shader = render_get_default_shader();
}

static void draw_rmodel(renderModel rmodel){
    Model model = rmodel->model;

    Shader old_shader = model.materials[0].shader;
    model.materials[0].shader = default_shader;

    //TraceLog(LOG_INFO,"%d model_instances",rmodel->n_instances);
    for (int i = 0; i < model.meshCount; i++)
    {
        Color color = model.materials[model.meshMaterial[i]].maps[MATERIAL_MAP_DIFFUSE].color;

        for (int j = 0; j < rmodel->n_instances; j++){
            Color tint = rmodel->tints[j];
            Matrix transform = rmodel->transforms[j];
            Color colorTint = WHITE;
            colorTint.r = (unsigned char)((((float)color.r/255.0f)*((float)tint.r/255.0f))*255.0f);
            colorTint.g = (unsigned char)((((float)color.g/255.0f)*((float)tint.g/255.0f))*255.0f);
            colorTint.b = (unsigned char)((((float)color.b/255.0f)*((float)tint.b/255.0f))*255.0f);
            colorTint.a = (unsigned char)((((float)color.a/255.0f)*((float)tint.a/255.0f))*255.0f);

            model.materials[model.meshMaterial[i]].maps[MATERIAL_MAP_DIFFUSE].color = colorTint;
            DrawMesh(model.meshes[i], model.materials[model.meshMaterial[i]], transform);
            model.materials[model.meshMaterial[i]].maps[MATERIAL_MAP_DIFFUSE].color = color;
        }
    }

    model.materials[0].shader = old_shader;
}

static void draw_rmodel_no_shader(renderModel rmodel){
    Model model = rmodel->model;

    for (int i = 0; i < model.meshCount; i++)
    {
        Color color = model.materials[model.meshMaterial[i]].maps[MATERIAL_MAP_DIFFUSE].color;

        for (int j = 0; j < rmodel->n_instances; j++){
            Color tint = rmodel->tints[j];
            Matrix transform = rmodel->transforms[j];
            Color colorTint = WHITE;
            colorTint.r = (unsigned char)((((float)color.r/255.0f)*((float)tint.r/255.0f))*255.0f);
            colorTint.g = (unsigned char)((((float)color.g/255.0f)*((float)tint.g/255.0f))*255.0f);
            colorTint.b = (unsigned char)((((float)color.b/255.0f)*((float)tint.b/255.0f))*255.0f);
            colorTint.a = (unsigned char)((((float)color.a/255.0f)*((float)tint.a/255.0f))*255.0f);

            model.materials[model.meshMaterial[i]].maps[MATERIAL_MAP_DIFFUSE].color = colorTint;
            DrawMesh(model.meshes[i], model.materials[model.meshMaterial[i]], transform);
            model.materials[model.meshMaterial[i]].maps[MATERIAL_MAP_DIFFUSE].color = color;
        }
    }
}

static void draw_object(struct render_object obj){
    Shader old_shader = obj.model.materials[0].shader;
    obj.model.materials[0].shader = default_shader;
    DrawModelEx(obj.model,obj.pos,obj.rotation_axis,obj.rotation_amount,obj.scale,obj.tint);
    obj.model.materials[0].shader = old_shader;
}

static void draw_object_no_shader(struct render_object obj){
    //if(obj.model.materials[0].shader.id == default_shader.id){
        //TraceLog(LOG_ERROR,"wrong shader!!!");
    //}
    DrawModelEx(obj.model,obj.pos,obj.rotation_axis,obj.rotation_amount,obj.scale,obj.tint);
}

void render_draw_all_no_shader(void){
    for (int i = 0; i < n_objects; i++){
        draw_object_no_shader(objects[i]);
    }
    for (int i = 0; i < n_rmodels; i++){
        draw_rmodel_no_shader(rmodels[i]);
    }
}

void render_begin(Camera3D camera){
    current_camera = camera;
    render_set_cam_pos(current_camera.position);
    n_objects = 0;
    draw_grid = 0;
    n_rmodels = 0;
}

void render_model(Model model, fluxTransform transform, Color tint){
    assert(n_objects < RENDERER_MAX_OBJECTS);
    struct render_object* obj = &objects[n_objects];
    n_objects++;

    obj->model = model;
    obj->pos = transform.pos;
    obj->scale = transform.scale;
    Quaternion qrot = QuaternionFromEuler(Wrap(transform.rot.x,0,2*M_PI),Wrap(transform.rot.y,0,2*M_PI),Wrap(transform.rot.z,0,2*M_PI));
    QuaternionToAxisAngle(qrot,&obj->rotation_axis,&obj->rotation_amount);
    obj->tint = tint;
}

static void draw_all(void){
    for (int i = 0; i < n_objects; i++){
        draw_object(objects[i]);
    }
    for (int i = 0; i < n_rmodels; i++){
        draw_rmodel(rmodels[i]);
    }
}

void render_end(void){
    render_calculate_shadows();
    ClearBackground(BLACK);
    BeginMode3D(current_camera);

    render_draw_skybox();

    draw_all();

    if (draw_grid)
        DrawGrid(n_grid,spacing_grid);

    EndMode3D();
}

void render_draw_grid(int n, float s){
    draw_grid = 1;
    n_grid = n;
    spacing_grid = s;
}

void render_close(void){
    render_unload_default_shader();
}

Camera3D render_get_current_cam(void){
    return current_camera;
}

